{
  "version": 3,
  "sources": ["../../../src/decorators/shared/model.ts"],
  "sourcesContent": ["import { EMPTY_OBJECT } from '@sequelize/utils';\nimport { cloneDataType } from '../../abstract-dialect/data-types-utils.js';\nimport { BaseError } from '../../errors/base-error.js';\nimport { mergeModelOptions } from '../../model-definition.js';\nimport { initModel } from '../../model-typescript.js';\nimport type { AttributeOptions, ModelAttributes, ModelOptions, ModelStatic } from '../../model.js';\nimport type { Sequelize } from '../../sequelize.js';\nimport { isModelStatic } from '../../utils/model-utils.js';\nimport { cloneDeep, getAllOwnEntries } from '../../utils/object.js';\nimport type { InheritedAttributeOptions } from '../legacy/attribute.js';\n\nexport interface RegisteredModelOptions extends ModelOptions {\n  /**\n   * Abstract models cannot be used directly, or registered.\n   * They exist only to be extended by other models.\n   */\n  abstract?: boolean;\n}\n\nexport interface RegisteredAttributeOptions {\n  [key: string]: InheritedAttributeOptions;\n}\n\ninterface RegisteredOptions {\n  model: RegisteredModelOptions;\n  attributes: RegisteredAttributeOptions;\n}\n\nconst registeredOptions = new WeakMap<ModelStatic, RegisteredOptions>();\n\n/**\n * Registers model options for future registering of the Model using Model.init\n * Subsequent calls for the same model & attributeName will be merged, with the newer call taking precedence.\n * 'sequelize' option is not accepted here. Pass it through `Model.init` when registering the model.\n *\n * @param model\n * @param options\n */\nexport function registerModelOptions(model: ModelStatic, options: RegisteredModelOptions): void {\n  if (!registeredOptions.has(model)) {\n    registeredOptions.set(model, { model: options, attributes: {} });\n\n    return;\n  }\n\n  // merge-able: scopes, indexes\n  const existingModelOptions = registeredOptions.get(model)!.model;\n\n  try {\n    mergeModelOptions(existingModelOptions, options, false);\n  } catch (error) {\n    throw new BaseError(\n      `Multiple decorators are trying to register conflicting options on model ${model.name}`,\n      { cause: error },\n    );\n  }\n}\n\n/**\n * Registers attribute options for future registering of the Model using Model.init\n * Subsequent calls for the same model & attributeName will be merged, with the newer call taking precedence.\n *\n * @param model\n * @param attributeName\n * @param options\n */\nexport function registerModelAttributeOptions(\n  model: ModelStatic,\n  attributeName: string,\n  options: Partial<AttributeOptions>,\n): void {\n  if (!registeredOptions.has(model)) {\n    registeredOptions.set(model, {\n      model: {},\n      attributes: {\n        [attributeName]: options,\n      },\n    });\n\n    return;\n  }\n\n  const existingAttributesOptions = registeredOptions.get(model)!.attributes;\n  if (!(attributeName in existingAttributesOptions)) {\n    existingAttributesOptions[attributeName] = options;\n\n    return;\n  }\n\n  const existingOptions = existingAttributesOptions[attributeName];\n\n  mergeAttributeOptions(attributeName, model, existingOptions, options, false);\n}\n\nexport function mergeAttributeOptions(\n  attributeName: string,\n  model: ModelStatic,\n  existingOptions: Partial<AttributeOptions>,\n  options: Partial<AttributeOptions>,\n  overrideOnConflict: boolean,\n): Partial<AttributeOptions> {\n  for (const [optionName, optionValue] of Object.entries(options) as Array<\n    [keyof AttributeOptions, any]\n  >) {\n    if (existingOptions[optionName] === undefined) {\n      // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error -- This error only occurs on TS 5.3+\n      // @ts-ignore -- this function is very fuzzy in terms of typing due to how generic it is.\n      existingOptions[optionName] = optionValue;\n      continue;\n    }\n\n    // These are objects. We merge their properties, unless the same key is used in both values.\n    if (optionName === 'validate') {\n      for (const [subOptionName, subOptionValue] of getAllOwnEntries(optionValue)) {\n        if (subOptionName in existingOptions[optionName] && !overrideOnConflict) {\n          throw new Error(\n            `Multiple decorators are attempting to register option ${optionName}[${JSON.stringify(subOptionName)}] of attribute ${attributeName} on model ${model.name}.`,\n          );\n        }\n\n        // @ts-expect-error -- runtime type checking is enforced by model\n        existingOptions[optionName][subOptionName] = subOptionValue;\n      }\n\n      continue;\n    }\n\n    if (optionName === 'index' || optionName === 'unique') {\n      if (!existingOptions[optionName]) {\n        existingOptions[optionName] = [];\n      } else if (!Array.isArray(existingOptions[optionName])) {\n        // @ts-expect-error -- runtime type checking is enforced by model\n        existingOptions[optionName] = [existingOptions[optionName]];\n      }\n\n      if (Array.isArray(optionValue)) {\n        // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error -- became valid in TS 5.8\n        // @ts-ignore -- runtime type checking is enforced by model\n        existingOptions[optionName] = [...existingOptions[optionName], ...optionValue];\n      } else {\n        existingOptions[optionName] = [...existingOptions[optionName], optionValue];\n      }\n\n      continue;\n    }\n\n    if (optionValue === existingOptions[optionName] || overrideOnConflict) {\n      continue;\n    }\n\n    throw new Error(\n      `Multiple decorators are attempting to set different values for the option ${optionName} of attribute ${attributeName} on model ${model.name}.`,\n    );\n  }\n\n  return existingOptions;\n}\n\nexport function initDecoratedModel(model: ModelStatic, sequelize: Sequelize): boolean {\n  const isAbstract = registeredOptions.get(model)?.model.abstract;\n\n  if (isAbstract) {\n    return false;\n  }\n\n  const modelOptions = getRegisteredModelOptions(model);\n  const attributeOptions = getRegisteredAttributeOptions(model);\n\n  initModel(model, attributeOptions as ModelAttributes, {\n    ...modelOptions,\n    sequelize,\n  });\n\n  return true;\n}\n\nconst NON_INHERITABLE_MODEL_OPTIONS = ['modelName', 'name', 'tableName'] as const;\n\nfunction getRegisteredModelOptions(model: ModelStatic): ModelOptions {\n  const modelOptions = registeredOptions.get(model)?.model ?? (EMPTY_OBJECT as ModelOptions);\n\n  const parentModel = Object.getPrototypeOf(model);\n  if (isModelStatic(parentModel)) {\n    const parentModelOptions: ModelOptions = { ...getRegisteredModelOptions(parentModel) };\n\n    for (const nonInheritableOption of NON_INHERITABLE_MODEL_OPTIONS) {\n      delete parentModelOptions[nonInheritableOption];\n    }\n\n    // options that must be cloned\n    parentModelOptions.indexes = cloneDeep(parentModelOptions.indexes);\n    parentModelOptions.defaultScope = cloneDeep(parentModelOptions.defaultScope);\n    parentModelOptions.scopes = cloneDeep(parentModelOptions.scopes);\n    parentModelOptions.validate = cloneDeep(parentModelOptions.validate);\n    parentModelOptions.hooks = cloneDeep(parentModelOptions.hooks);\n\n    return mergeModelOptions(parentModelOptions, modelOptions, true);\n  }\n\n  return modelOptions;\n}\n\nfunction getRegisteredAttributeOptions(model: ModelStatic): RegisteredAttributeOptions {\n  const descendantAttributes: RegisteredAttributeOptions = {\n    ...(registeredOptions.get(model)?.attributes ?? EMPTY_OBJECT),\n  };\n  const insertAfterAttributes: RegisteredAttributeOptions = {};\n  const insertBeforeAttributes: RegisteredAttributeOptions = {};\n\n  const parentModel = Object.getPrototypeOf(model);\n  if (isModelStatic(parentModel)) {\n    const parentAttributes: RegisteredAttributeOptions = getRegisteredAttributeOptions(parentModel);\n\n    for (const attributeName of Object.keys(parentAttributes)) {\n      const parentAttribute = { ...parentAttributes[attributeName] };\n      if (parentAttribute.insertBefore && parentAttribute.insertAfter) {\n        throw new Error(\n          `Attribute ${attributeName} on model ${model.name} cannot have both 'insertBefore' and 'insertAfter' set to true.`,\n        );\n      }\n\n      if (parentAttribute.type) {\n        if (typeof parentAttribute.type === 'function') {\n          parentAttribute.type = new parentAttribute.type();\n        } else {\n          parentAttribute.type = cloneDataType(parentAttribute.type);\n        }\n      }\n\n      // options that must be cloned\n      parentAttribute.unique = cloneDeep(parentAttribute.unique);\n      parentAttribute.index = cloneDeep(parentAttribute.index);\n      parentAttribute.references = cloneDeep(parentAttribute.references);\n      parentAttribute.validate = cloneDeep(parentAttribute.validate);\n\n      const descendantAttribute = descendantAttributes[attributeName];\n      if (descendantAttribute) {\n        descendantAttributes[attributeName] = mergeAttributeOptions(\n          attributeName,\n          model,\n          parentAttribute,\n          descendantAttribute,\n          true,\n        );\n      } else if (parentAttribute.insertBefore) {\n        insertBeforeAttributes[attributeName] = parentAttribute;\n      } else {\n        insertAfterAttributes[attributeName] = parentAttribute;\n      }\n    }\n  }\n\n  return {\n    ...insertBeforeAttributes,\n    ...descendantAttributes,\n    ...insertAfterAttributes,\n  };\n}\n\nexport function isDecoratedModel(model: ModelStatic): boolean {\n  return registeredOptions.has(model);\n}\n"],
  "mappings": "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",
  "names": []
}
