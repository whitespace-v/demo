{
  "version": 3,
  "sources": ["../src/query-interface.ts"],
  "sourcesContent": ["import type {\n  AddConstraintOptions,\n  AttributeOptions,\n  ConstraintDescription,\n  ConstraintType,\n  DataType,\n  DescribeTableOptions,\n  QiDropAllTablesOptions,\n  QueryRawOptions,\n  RemoveColumnOptions,\n  RemoveConstraintOptions,\n  ShowConstraintsOptions,\n  TableOrModel,\n} from '@sequelize/core';\nimport {\n  AbstractQueryInterface,\n  BaseError,\n  QueryTypes,\n  UnknownConstraintError,\n} from '@sequelize/core';\nimport { isErrorWithStringCode } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/check.js';\nimport {\n  noSchemaDelimiterParameter,\n  noSchemaParameter,\n} from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/deprecations.js';\nimport { withSqliteForeignKeysOff } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/sql.js';\nimport isEmpty from 'lodash/isEmpty';\nimport type { SqliteDialect } from './dialect.js';\nimport { SqliteQueryInterfaceInternal } from './query-interface.internal.js';\nimport type { SqliteColumnsDescription } from './query-interface.types.js';\n\nexport class SqliteQueryInterface<\n  Dialect extends SqliteDialect = SqliteDialect,\n> extends AbstractQueryInterface<Dialect> {\n  readonly #internalQueryInterface: SqliteQueryInterfaceInternal;\n\n  constructor(dialect: Dialect, internalQueryInterface?: SqliteQueryInterfaceInternal) {\n    internalQueryInterface ??= new SqliteQueryInterfaceInternal(dialect);\n\n    super(dialect, internalQueryInterface);\n    this.#internalQueryInterface = internalQueryInterface;\n  }\n\n  async dropAllTables(options?: QiDropAllTablesOptions): Promise<void> {\n    const skip = options?.skip || [];\n    const allTables = await this.listTables(options);\n    const tableNames = allTables.filter(tableName => !skip.includes(tableName.tableName));\n\n    await withSqliteForeignKeysOff(this.sequelize, options, async () => {\n      for (const table of tableNames) {\n        // eslint-disable-next-line no-await-in-loop\n        await this.dropTable(table, options);\n      }\n    });\n  }\n\n  async describeTable(\n    tableName: TableOrModel,\n    options?: DescribeTableOptions,\n  ): Promise<SqliteColumnsDescription> {\n    const table = this.queryGenerator.extractTableDetails(tableName);\n\n    if (typeof options === 'string') {\n      noSchemaParameter();\n      table.schema = options;\n    }\n\n    if (typeof options === 'object' && options !== null) {\n      if (options.schema) {\n        noSchemaParameter();\n        table.schema = options.schema;\n      }\n\n      if (options.schemaDelimiter) {\n        noSchemaDelimiterParameter();\n        table.delimiter = options.schemaDelimiter;\n      }\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(table);\n    try {\n      const data = (await this.sequelize.queryRaw(sql, {\n        ...options,\n        type: QueryTypes.DESCRIBE,\n      })) as SqliteColumnsDescription;\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (isEmpty(data)) {\n        throw new Error(\n          `No description found for table ${table.tableName}${table.schema ? ` in schema ${table.schema}` : ''}. Check the table name and schema; remember, they _are_ case sensitive.`,\n        );\n      }\n\n      // This is handled by copying indexes over,\n      // we don't use \"unique\" because it creates an index with a name\n      // we can't control\n      for (const column of Object.values(data)) {\n        column.unique = false;\n      }\n\n      const indexes = await this.showIndex(tableName, options);\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== undefined) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n\n      // Sqlite requires the foreign keys added to the column definitions\n      // when describing a table as this is required in the replaceTableQuery\n      const foreignKeys = await this.showConstraints(tableName, {\n        ...options,\n        constraintType: 'FOREIGN KEY',\n      });\n      for (const foreignKey of foreignKeys) {\n        for (const [index, columnName] of foreignKey.columnNames!.entries()) {\n          // Add constraints to column definition\n          Object.assign(data[columnName], {\n            references: {\n              table: foreignKey.referencedTableName,\n              key: foreignKey.referencedColumnNames!.at(index),\n            },\n            onUpdate: foreignKey.updateAction,\n            onDelete: foreignKey.deleteAction,\n          });\n        }\n      }\n\n      return data;\n    } catch (error) {\n      if (\n        error instanceof BaseError &&\n        isErrorWithStringCode(error.cause) &&\n        error.cause.code === 'ER_NO_SUCH_TABLE'\n      ) {\n        throw new Error(\n          `No description found for table ${table.tableName}${table.schema ? ` in schema ${table.schema}` : ''}. Check the table name and schema; remember, they _are_ case sensitive.`,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  async addConstraint(tableName: TableOrModel, options: AddConstraintOptions): Promise<void> {\n    if (!options.fields) {\n      throw new Error('Fields must be specified through options.fields');\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    const constraintSnippet = this.queryGenerator._TEMPORARY_getConstraintSnippet(\n      tableName,\n      options,\n    );\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {\n      ...options,\n      raw: true,\n      type: QueryTypes.SELECT,\n    });\n\n    if (!describeCreateTable.length || !('sql' in describeCreateTable[0])) {\n      throw new Error('Unable to find constraints for table. Perhaps the table does not exist?');\n    }\n\n    let { sql: createTableSql } = describeCreateTable[0] as { sql: string };\n    // Replace double quotes with backticks and ending ')' with constraint snippet\n    createTableSql = createTableSql\n      .replaceAll('\"', '`')\n      .replace(/\\);?$/, `, ${constraintSnippet})`);\n\n    const fields = await this.describeTable(tableName, options);\n    const sql = this.queryGenerator._replaceTableQuery(tableName, fields, createTableSql);\n    await this.#internalQueryInterface.executeQueriesSequentially(sql, { ...options, raw: true });\n  }\n\n  async removeConstraint(\n    tableName: TableOrModel,\n    constraintName: string,\n    options?: RemoveConstraintOptions,\n  ): Promise<void> {\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {\n      ...options,\n      raw: true,\n      type: QueryTypes.SELECT,\n    });\n\n    if (!describeCreateTable.length || !('sql' in describeCreateTable[0])) {\n      throw new Error('Unable to find constraints for table. Perhaps the table does not exist?');\n    }\n\n    const { sql: createTableSql } = describeCreateTable[0] as { sql: string };\n    const constraints = await this.showConstraints(tableName, options);\n    const constraint = constraints.find(c => c.constraintName === constraintName);\n\n    if (!constraint) {\n      const table = this.queryGenerator.extractTableDetails(tableName);\n      throw new UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${table.tableName} does not exist`,\n        constraint: constraintName,\n        table: table.tableName,\n      });\n    }\n\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.definition}`;\n\n    if (constraint.constraintType === 'FOREIGN KEY') {\n      constraintSnippet = `, CONSTRAINT ${constraint.constraintName} FOREIGN KEY`;\n      const columns = constraint\n        .columnNames!.map(columnName => this.queryGenerator.quoteIdentifier(columnName))\n        .join(', ');\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referencedTableName!);\n      const referenceTableColumns = constraint\n        .referencedColumnNames!.map(columnName => this.queryGenerator.quoteIdentifier(columnName))\n        .join(', ');\n      constraintSnippet += ` (${columns})`;\n      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableColumns})`;\n      constraintSnippet += constraint.updateAction ? ` ON UPDATE ${constraint.updateAction}` : '';\n      constraintSnippet += constraint.deleteAction ? ` ON DELETE ${constraint.deleteAction}` : '';\n    } else if (['PRIMARY KEY', 'UNIQUE'].includes(constraint.constraintType)) {\n      constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType}`;\n      const columns = constraint\n        .columnNames!.map(columnName => this.queryGenerator.quoteIdentifier(columnName))\n        .join(', ');\n      constraintSnippet += ` (${columns})`;\n    }\n\n    const fields = await this.describeTable(tableName, options);\n    // Replace double quotes with backticks and remove constraint snippet\n    const sql = this.queryGenerator._replaceTableQuery(\n      tableName,\n      fields,\n      createTableSql.replaceAll('\"', '`').replace(constraintSnippet, ''),\n    );\n    await this.#internalQueryInterface.executeQueriesSequentially(sql, { ...options, raw: true });\n  }\n\n  async showConstraints(\n    tableName: TableOrModel,\n    options?: ShowConstraintsOptions,\n  ): Promise<ConstraintDescription[]> {\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {\n      ...options,\n      raw: true,\n      type: QueryTypes.SELECT,\n    });\n\n    if (!describeCreateTable.length || !('sql' in describeCreateTable[0])) {\n      throw new Error('Unable to find constraints for table. Perhaps the table does not exist?');\n    }\n\n    const { sql: createTableSql } = describeCreateTable[0] as { sql: string };\n    const match = /CREATE TABLE (?:`|'|\")(\\S+)(?:`|'|\") \\((.+)\\)/.exec(createTableSql);\n    const data: ConstraintDescription[] = [];\n\n    if (match) {\n      const [, constraintTableName, attributeSQL] = match;\n      const keys = [];\n      const attributes = [];\n      const constraints = [];\n      const sqlAttributes = attributeSQL.split(/,(?![^(]*\\))/).map(attr => attr.trim());\n      for (const attribute of sqlAttributes) {\n        if (attribute.startsWith('CONSTRAINT')) {\n          constraints.push(attribute);\n        } else if (attribute.startsWith('PRIMARY KEY') || attribute.startsWith('FOREIGN KEY')) {\n          keys.push(attribute);\n        } else {\n          attributes.push(attribute);\n        }\n      }\n\n      for (const attribute of attributes) {\n        const [, column, type] = attribute.match(/`(\\S+)` (.+)/) || [];\n        if (/\\bPRIMARY KEY\\b/.test(type)) {\n          data.push({\n            constraintSchema: '',\n            constraintName: 'PRIMARY',\n            constraintType: 'PRIMARY KEY',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: [column],\n          });\n        } else if (/\\bREFERENCES\\b/.test(type)) {\n          const deleteAction = type.match(/ON DELETE (\\w+(?: (?!ON UPDATE)\\w+)?)/);\n          const updateAction = type.match(/ON UPDATE (\\w+(?: (?!ON DELETE)\\w+)?)/);\n          const [, referencedTableName, referencedColumnNames] =\n            type.match(/REFERENCES `(\\S+)` \\(`(\\S+)`\\)/) || [];\n\n          data.push({\n            constraintSchema: '',\n            constraintName: 'FOREIGN',\n            constraintType: 'FOREIGN KEY',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: [column],\n            referencedTableSchema: '',\n            referencedTableName: referencedTableName ?? '',\n            referencedColumnNames: [referencedColumnNames],\n            deleteAction: deleteAction?.at(1) ?? '',\n            updateAction: updateAction?.at(1) ?? '',\n          });\n        } else if (/\\bUNIQUE\\b/.test(type)) {\n          data.push({\n            constraintSchema: '',\n            constraintName: 'UNIQUE',\n            constraintType: 'UNIQUE',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: [column],\n          });\n        } else if (/\\bCHECK\\b/.test(type)) {\n          const definition = type.match(/CHECK (.+)/);\n\n          data.push({\n            constraintSchema: '',\n            constraintName: 'CHECK',\n            constraintType: 'CHECK',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: [column],\n            definition: definition ? (definition[1] ?? '') : '',\n          });\n        }\n      }\n\n      for (const constraint of constraints) {\n        const [, constraintName, constraintType, definition] =\n          constraint.match(/CONSTRAINT (?:`|'|\")(\\S+)(?:`|'|\") (\\w+(?: \\w+)?) (.+)/) || [];\n        if (/\\bPRIMARY KEY\\b/.test(constraint)) {\n          const columnsMatch = [...definition.matchAll(/`(\\S+)`/g)];\n\n          data.push({\n            constraintSchema: '',\n            constraintName,\n            constraintType: 'PRIMARY KEY',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: columnsMatch.map(col => col[1]),\n          });\n        } else if (/\\bREFERENCES\\b/.test(constraint)) {\n          const deleteAction = definition.match(/ON DELETE (\\w+(?: (?!ON UPDATE)\\w+)?)/);\n          const updateAction = definition.match(/ON UPDATE (\\w+(?: (?!ON DELETE)\\w+)?)/);\n          const [, rawColumnNames, referencedTableName, rawReferencedColumnNames] =\n            definition.match(\n              /\\(([^\\s,]+(?:,\\s?[^\\s,]+)*)\\) REFERENCES `(\\S+)` \\(([^\\s,]+(?:,\\s?[^\\s,]+)*)\\)/,\n            ) || [];\n          const columnsMatch = [...rawColumnNames.matchAll(/`(\\S+)`/g)];\n          const referencedColumnNames = [...rawReferencedColumnNames.matchAll(/`(\\S+)`/g)];\n\n          data.push({\n            constraintSchema: '',\n            constraintName,\n            constraintType: 'FOREIGN KEY',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: columnsMatch.map(col => col[1]),\n            referencedTableSchema: '',\n            referencedTableName: referencedTableName ?? '',\n            referencedColumnNames: referencedColumnNames.map(col => col[1]),\n            deleteAction: deleteAction?.at(1) ?? '',\n            updateAction: updateAction?.at(1) ?? '',\n          });\n        } else if (['CHECK', 'DEFAULT', 'UNIQUE'].includes(constraintType)) {\n          const columnsMatch = [...definition.matchAll(/`(\\S+)`/g)];\n\n          data.push({\n            constraintSchema: '',\n            constraintName,\n            constraintType: constraintType as ConstraintType,\n            tableSchema: '',\n            tableName: constraintTableName,\n            ...(constraintType !== 'CHECK' && { columnNames: columnsMatch.map(col => col[1]) }),\n            ...(constraintType !== 'UNIQUE' && { definition }),\n          });\n        }\n      }\n\n      for (const key of keys) {\n        const [, constraintType, rawColumnNames] =\n          key.match(/(\\w+(?: \\w+)?)\\s?\\(([^\\s,]+(?:,\\s?[^\\s,]+)*)\\)/) || [];\n        const columnsMatch = [...rawColumnNames.matchAll(/`(\\S+)`/g)];\n        const columnNames = columnsMatch.map(col => col[1]);\n\n        if (constraintType === 'PRIMARY KEY') {\n          data.push({\n            constraintSchema: '',\n            constraintName: 'PRIMARY',\n            constraintType,\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames,\n          });\n        } else if (constraintType === 'FOREIGN KEY') {\n          const deleteAction = key.match(/ON DELETE (\\w+(?: (?!ON UPDATE)\\w+)?)/);\n          const updateAction = key.match(/ON UPDATE (\\w+(?: (?!ON DELETE)\\w+)?)/);\n          const [, referencedTableName, rawReferencedColumnNames] =\n            key.match(/REFERENCES `(\\S+)` \\(([^\\s,]+(?:,\\s?[^\\s,]+)*)\\)/) || [];\n          const referencedColumnNames = [...rawReferencedColumnNames.matchAll(/`(\\S+)`/g)];\n\n          data.push({\n            constraintSchema: '',\n            constraintName: 'FOREIGN',\n            constraintType,\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames,\n            referencedTableSchema: '',\n            referencedTableName,\n            referencedColumnNames: referencedColumnNames.map(col => col[1]),\n            deleteAction: deleteAction?.at(1) ?? '',\n            updateAction: updateAction?.at(1) ?? '',\n          });\n        }\n      }\n    } else {\n      throw new Error(`Could not parse constraints from SQL: ${createTableSql}`);\n    }\n\n    let constraintData = data;\n\n    if (options?.columnName) {\n      constraintData = constraintData.filter(constraint =>\n        constraint.columnNames?.includes(options.columnName!),\n      );\n      constraintData = constraintData.map(constraint => {\n        if (constraint.columnNames) {\n          constraint.columnNames = constraint.columnNames.filter(\n            column => column === options.columnName,\n          );\n        }\n\n        return constraint;\n      });\n    }\n\n    if (options?.constraintName) {\n      constraintData = constraintData.filter(\n        constraint => constraint.constraintName === options.constraintName,\n      );\n    }\n\n    if (options?.constraintType) {\n      constraintData = constraintData.filter(\n        constraint => constraint.constraintType === options.constraintType,\n      );\n    }\n\n    return constraintData;\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to remove columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but without the obsolete column.\n   *\n   * @param tableName\n   * @param removeColumn\n   * @param options\n   */\n  async removeColumn(\n    tableName: TableOrModel,\n    removeColumn: string,\n    options?: RemoveColumnOptions,\n  ): Promise<void> {\n    const fields = await this.describeTable(tableName, options);\n    delete fields[removeColumn];\n\n    await this.#internalQueryInterface.alterTableInternal(tableName, fields, options);\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to change columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a modified version of the respective column.\n   *\n   * @param tableName\n   * @param columnName\n   * @param dataTypeOrOptions\n   * @param options\n   */\n  async changeColumn(\n    tableName: TableOrModel,\n    columnName: string,\n    dataTypeOrOptions: DataType | AttributeOptions,\n    options?: QueryRawOptions,\n  ): Promise<void> {\n    const columns = await this.describeTable(tableName, options);\n    for (const column of Object.values(columns)) {\n      // This is handled by copying indexes over,\n      // we don't use \"unique\" because it creates an index with a name\n      // we can't control\n      delete column.unique;\n    }\n\n    Object.assign(columns[columnName], this.sequelize.normalizeAttribute(dataTypeOrOptions));\n\n    await this.#internalQueryInterface.alterTableInternal(tableName, columns, options);\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to rename columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a renamed version of the respective column.\n   *\n   * @param tableName\n   * @param attrNameBefore\n   * @param attrNameAfter\n   * @param options\n   */\n  async renameColumn(\n    tableName: TableOrModel,\n    attrNameBefore: string,\n    attrNameAfter: string,\n    options?: QueryRawOptions,\n  ): Promise<void> {\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n\n    fields[attrNameAfter] = { ...fields[attrNameBefore] };\n    delete fields[attrNameBefore];\n\n    const sql = this.queryGenerator._replaceColumnQuery(\n      tableName,\n      attrNameBefore,\n      attrNameAfter,\n      fields,\n    );\n    await this.#internalQueryInterface.executeQueriesSequentially(sql, { ...options, raw: true });\n  }\n}\n"],
  "mappings": "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",
  "names": ["isEmpty"]
}
