"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var connection_manager_exports = {};
__export(connection_manager_exports, {
  OPEN_CREATE: () => import_sqlite3.OPEN_CREATE,
  OPEN_FULLMUTEX: () => import_sqlite3.OPEN_FULLMUTEX,
  OPEN_PRIVATECACHE: () => import_sqlite3.OPEN_PRIVATECACHE,
  OPEN_READONLY: () => import_sqlite3.OPEN_READONLY,
  OPEN_READWRITE: () => import_sqlite3.OPEN_READWRITE,
  OPEN_SHAREDCACHE: () => import_sqlite3.OPEN_SHAREDCACHE,
  OPEN_URI: () => import_sqlite3.OPEN_URI,
  SqliteConnectionManager: () => SqliteConnectionManager
});
module.exports = __toCommonJS(connection_manager_exports);
var import_core = require("@sequelize/core");
var import_logger = require("@sequelize/core/_non-semver-use-at-your-own-risk_/utils/logger.js");
var import_node = require("@sequelize/utils/node");
var import_promises = __toESM(require("node:fs/promises"));
var import_node_path = __toESM(require("node:path"));
var Sqlite3 = __toESM(require("sqlite3"));
var import_sqlite3 = require("sqlite3");
const debug = import_logger.logger.debugContext("connection:sqlite3");
const CLOSED_SYMBOL = Symbol("closed");
class SqliteConnectionManager extends import_core.AbstractConnectionManager {
  #lib;
  constructor(dialect) {
    super(dialect);
    this.#lib = this.dialect.options.sqlite3Module ?? Sqlite3;
  }
  async connect(options) {
    const storage = options.storage ?? import_node_path.default.join(process.cwd(), "sequelize.sqlite");
    const inMemory = storage === ":memory:";
    const isTemporaryStorage = inMemory || storage === "";
    if (isTemporaryStorage) {
      const pool = this.sequelize.pool;
      const writePool = pool.write;
      if (writePool.idleTimeoutMillis !== Infinity) {
        throw new Error(`SQLite is configured to use a temporary database, but the pool is configured to close idle connections, which would lead to data loss while the application is running.
To fix this, set the pool's idleTimeoutMillis to Infinity, or use a non-temporary database.`);
      }
      if (writePool.maxUsesPerResource !== Infinity) {
        throw new Error(`SQLite is configured to use a temporary database, but the pool is configured to close connections after ${writePool.maxUsesPerResources}, which would lead to data loss while the application is running.
To fix this, set the pool's maxUsesPerResource to Infinity, or use a non-temporary database.`);
      }
      if (writePool.maxSize !== 1) {
        throw new Error(`SQLite is configured to use a temporary database, but the pool is configured to allow more than one connection, which would create separate temporary databases.
To fix this, set the pool's maxSize to 1, or use a non-temporary database.`);
      }
      if (pool.read) {
        throw new Error(`SQLite is configured to use a temporary database, but read-replication is enabled, which would read a different temporary database.
To fix this, disable read replication, or use a non-temporary database.`);
      }
    }
    const defaultReadWriteMode = this.#lib.OPEN_READWRITE | this.#lib.OPEN_CREATE;
    const readWriteMode = options.mode ?? defaultReadWriteMode;
    const storageDir = import_node_path.default.dirname(storage);
    if (!isTemporaryStorage && (readWriteMode & this.#lib.OPEN_CREATE) !== 0 && !await (0, import_node.checkFileExists)(storageDir)) {
      await import_promises.default.mkdir(storageDir, { recursive: true });
    }
    const connection = await new Promise((resolve, reject) => {
      const connectionInstance = new this.#lib.Database(
        storage,
        readWriteMode,
        (err) => {
          if (err) {
            return void reject(new import_core.ConnectionError(err));
          }
          debug(`sqlite connection acquired`);
          resolve(connectionInstance);
        }
      );
    });
    if (options.password) {
      connection.run(`PRAGMA KEY=${this.sequelize.escape(options.password)}`);
    }
    if (this.dialect.options.foreignKeys !== false) {
      connection.run("PRAGMA FOREIGN_KEYS=ON");
    }
    return connection;
  }
  validate(connection) {
    return !connection[CLOSED_SYMBOL];
  }
  async disconnect(connection) {
    if (connection[CLOSED_SYMBOL]) {
      return;
    }
    return new Promise((resolve, reject) => {
      connection.close((err) => {
        if (err) {
          return reject(err);
        }
        debug(`sqlite connection released`);
        connection[CLOSED_SYMBOL] = true;
        resolve();
      });
    });
  }
}
//# sourceMappingURL=connection-manager.js.map
