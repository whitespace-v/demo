{
  "version": 3,
  "sources": ["../src/query.js"],
  "sourcesContent": ["'use strict';\n\nimport {\n  AbstractQuery,\n  DatabaseError,\n  EmptyResultError,\n  ForeignKeyConstraintError,\n  TimeoutError,\n  UniqueConstraintError,\n  ValidationErrorItem,\n} from '@sequelize/core';\nimport { logger } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/logger.js';\nimport isEqual from 'lodash/isEqual';\nimport isPlainObject from 'lodash/isPlainObject';\nimport merge from 'lodash/merge';\n\nconst debug = logger.debugContext('sql:sqlite3');\n\n// sqlite3 currently ignores bigint values, so we have to translate to string for now\n// There's a WIP here: https://github.com/TryGhost/node-sqlite3/pull/1501\nfunction stringifyIfBigint(value) {\n  if (typeof value === 'bigint') {\n    return value.toString();\n  }\n\n  return value;\n}\n\nexport class SqliteQuery extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, results) {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {\n      if (this.instance && this.instance.dataValues) {\n        // If we are creating an instance, and we get no rows, the create failed but did not throw.\n        // This probably means a conflict happened and was ignored, to avoid breaking a transaction.\n        if (this.isInsertQuery() && !this.isUpsertQuery() && results.length === 0) {\n          throw new EmptyResultError();\n        }\n\n        if (Array.isArray(results) && results[0]) {\n          for (const attributeOrColumnName of Object.keys(results[0])) {\n            const modelDefinition = this.model.modelDefinition;\n            const attribute = modelDefinition.columns.get(attributeOrColumnName);\n            const updatedValue = this._parseDatabaseValue(\n              results[0][attributeOrColumnName],\n              attribute?.type,\n            );\n\n            this.instance.set(attribute?.attributeName ?? attributeOrColumnName, updatedValue, {\n              raw: true,\n              comesFromDatabase: true,\n            });\n          }\n        }\n      }\n\n      if (this.isUpsertQuery()) {\n        return [this.instance, null];\n      }\n\n      return [\n        this.instance || (results && ((this.options.plain && results[0]) || results)) || undefined,\n        this.options.returning ? results.length : metaData.changes,\n      ];\n    }\n\n    if (this.isBulkUpdateQuery()) {\n      return this.options.returning ? this.handleSelectQuery(results) : metaData.changes;\n    }\n\n    if (this.isDeleteQuery()) {\n      return metaData.changes;\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      return results;\n    }\n\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(results);\n    }\n\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      const result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0,\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { 0: false, 1: true }[\n            result[_result.name].defaultValue\n          ];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replaceAll(\"'\", '');\n        }\n      }\n\n      return result;\n    }\n\n    if (this.isRawQuery()) {\n      return [results, metaData];\n    }\n\n    return this.instance;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n\n    const executeSql = async () => {\n      if (!parameters) {\n        parameters = [];\n      }\n\n      if (isPlainObject(parameters)) {\n        const newParameters = Object.create(null);\n\n        for (const key of Object.keys(parameters)) {\n          newParameters[`$${key}`] = stringifyIfBigint(parameters[key]);\n        }\n\n        parameters = newParameters;\n      } else {\n        parameters = parameters.map(stringifyIfBigint);\n      }\n\n      let response;\n      try {\n        if (method === 'run') {\n          response = await this.#runSeries(conn, sql, parameters);\n        } else {\n          response = await this.#allSeries(conn, sql, parameters);\n        }\n      } catch (error) {\n        error.sql = this.sql;\n        throw this.formatError(error);\n      }\n\n      complete();\n\n      return this._handleQueryResponse(response.statement, response.results);\n    };\n\n    return executeSql();\n  }\n\n  #allSeries(connection, query, parameters) {\n    return new Promise((resolve, reject) => {\n      connection.serialize(() => {\n        connection.all(query, parameters, function (err, results) {\n          if (err) {\n            reject(err);\n\n            return;\n          }\n\n          // node-sqlite3 passes the statement object as `this` to the callback\n          // eslint-disable-next-line no-invalid-this\n          resolve({ statement: this, results });\n        });\n      });\n    });\n  }\n\n  #runSeries(connection, query, parameters) {\n    return new Promise((resolve, reject) => {\n      connection.serialize(() => {\n        connection.run(query, parameters, function (err, results) {\n          if (err) {\n            reject(err);\n\n            return;\n          }\n\n          // node-sqlite3 passes the statement object as `this` to the callback\n          // eslint-disable-next-line no-invalid-this\n          resolve({ statement: this, results });\n        });\n      });\n    });\n  }\n\n  formatError(err) {\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT_UNIQUE':\n      case 'SQLITE_CONSTRAINT_PRIMARYKEY':\n      case 'SQLITE_CONSTRAINT_TRIGGER':\n      case 'SQLITE_CONSTRAINT_FOREIGNKEY':\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new ForeignKeyConstraintError({\n            cause: err,\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(\n            new ValidationErrorItem(\n              this.getUniqueConstraintErrorMessage(field),\n              'unique violation', // ValidationErrorItem.Origins.DB,\n              field,\n              this.instance && this.instance[field],\n              this.instance,\n              'not_unique',\n            ),\n          );\n        }\n\n        if (this.model) {\n          for (const index of this.model.getIndexes()) {\n            if (index.unique && isEqual(index.fields, fields) && index.msg) {\n              message = index.msg;\n              break;\n            }\n          }\n        }\n\n        return new UniqueConstraintError({ message, errors, cause: err, fields });\n      }\n\n      case 'SQLITE_BUSY':\n        return new TimeoutError(err);\n\n      default:\n        return new DatabaseError(err);\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(\n      data.reverse().map(async item => {\n        item.fields = [];\n        item.primary = false;\n        item.unique = Boolean(item.unique);\n        item.constraintName = item.name;\n        const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n        for (const column of columns) {\n          item.fields[column.seqno] = {\n            attribute: column.name,\n            length: undefined,\n            order: undefined,\n          };\n        }\n\n        return item;\n      }),\n    );\n  }\n\n  getDatabaseMethod() {\n    if (\n      this.isBulkUpdateQuery() ||\n      this.isInsertQuery() ||\n      this.isUpdateQuery() ||\n      this.isUpsertQuery()\n    ) {\n      return this.options.returning ? 'all' : 'run';\n    }\n\n    if (\n      this.isDeleteQuery() ||\n      this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase())\n    ) {\n      return 'run';\n    }\n\n    return 'all';\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,kBAQO;AACP,oBAAuB;AACvB,qBAAoB;AACpB,2BAA0B;AAC1B,mBAAkB;AAElB,MAAM,QAAQ,qBAAO,aAAa,aAAa;AAI/C,SAAS,kBAAkB,OAAO;AAChC,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO,MAAM,SAAS;AAAA,EACxB;AAEA,SAAO;AACT;AAEO,MAAM,oBAAoB,0BAAc;AAAA,EAC7C,mBAAmB;AACjB,WAAO;AAAA,EACT;AAAA,EAEA,eAAe,SAAS,QAAQ;AAC9B,UAAM,MAAM,CAAC;AAEb,QAAI,SAAS;AACX,iBAAW,YAAY,SAAS;AAC9B,YAAI;AACJ,YAAI,CAAC,QAAQ;AACX,gBAAM,SAAS;AAAA,QACjB,OAAO;AACL,gBAAM,GAAG,MAAM,IAAI,SAAS,EAAE;AAAA,QAChC;AAEA,YAAI,GAAG,IAAI,SAAS;AAEpB,YAAI,SAAS,SAAS;AACpB,2BAAAA,SAAM,KAAK,KAAK,eAAe,SAAS,SAAS,GAAG,CAAC;AAAA,QACvD;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,qBAAqB,UAAU,SAAS;AACtC,QAAI,KAAK,cAAc,KAAK,KAAK,cAAc,KAAK,KAAK,cAAc,GAAG;AACxE,UAAI,KAAK,YAAY,KAAK,SAAS,YAAY;AAG7C,YAAI,KAAK,cAAc,KAAK,CAAC,KAAK,cAAc,KAAK,QAAQ,WAAW,GAAG;AACzE,gBAAM,IAAI,6BAAiB;AAAA,QAC7B;AAEA,YAAI,MAAM,QAAQ,OAAO,KAAK,QAAQ,CAAC,GAAG;AACxC,qBAAW,yBAAyB,OAAO,KAAK,QAAQ,CAAC,CAAC,GAAG;AAC3D,kBAAM,kBAAkB,KAAK,MAAM;AACnC,kBAAM,YAAY,gBAAgB,QAAQ,IAAI,qBAAqB;AACnE,kBAAM,eAAe,KAAK;AAAA,cACxB,QAAQ,CAAC,EAAE,qBAAqB;AAAA,cAChC,WAAW;AAAA,YACb;AAEA,iBAAK,SAAS,IAAI,WAAW,iBAAiB,uBAAuB,cAAc;AAAA,cACjF,KAAK;AAAA,cACL,mBAAmB;AAAA,YACrB,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAEA,UAAI,KAAK,cAAc,GAAG;AACxB,eAAO,CAAC,KAAK,UAAU,IAAI;AAAA,MAC7B;AAEA,aAAO;AAAA,QACL,KAAK,YAAa,YAAa,KAAK,QAAQ,SAAS,QAAQ,CAAC,KAAM,YAAa;AAAA,QACjF,KAAK,QAAQ,YAAY,QAAQ,SAAS,SAAS;AAAA,MACrD;AAAA,IACF;AAEA,QAAI,KAAK,kBAAkB,GAAG;AAC5B,aAAO,KAAK,QAAQ,YAAY,KAAK,kBAAkB,OAAO,IAAI,SAAS;AAAA,IAC7E;AAEA,QAAI,KAAK,cAAc,GAAG;AACxB,aAAO,SAAS;AAAA,IAClB;AAEA,QAAI,KAAK,uBAAuB,GAAG;AACjC,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,cAAc,GAAG;AACxB,aAAO,KAAK,kBAAkB,OAAO;AAAA,IACvC;AAEA,QAAI,KAAK,sBAAsB,GAAG;AAChC,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,IAAI,SAAS,mBAAmB,GAAG;AAC1C,aAAO,KAAK,uBAAuB,OAAO;AAAA,IAC5C;AAEA,QAAI,KAAK,IAAI,SAAS,mBAAmB,GAAG;AAC1C,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,IAAI,SAAS,mBAAmB,GAAG;AAE1C,YAAM,SAAS,CAAC;AAEhB,UAAI;AACJ,iBAAW,WAAW,SAAS;AAC7B,YAAI,QAAQ,eAAe,MAAM;AAE/B,yBAAe;AAAA,QACjB,WAAW,QAAQ,eAAe,QAAQ;AAExC,yBAAe;AAAA,QACjB,OAAO;AACL,yBAAe,QAAQ;AAAA,QACzB;AAEA,eAAO,QAAQ,IAAI,IAAI;AAAA,UACrB,MAAM,QAAQ;AAAA,UACd,WAAW,QAAQ,YAAY;AAAA,UAC/B;AAAA,UACA,YAAY,QAAQ,OAAO;AAAA,QAC7B;AAEA,YAAI,OAAO,QAAQ,IAAI,EAAE,SAAS,cAAc;AAC9C,iBAAO,QAAQ,IAAI,EAAE,eAAe,EAAE,GAAG,OAAO,GAAG,KAAK,EACtD,OAAO,QAAQ,IAAI,EAAE,YACvB;AAAA,QACF;AAEA,YAAI,OAAO,OAAO,QAAQ,IAAI,EAAE,iBAAiB,UAAU;AACzD,iBAAO,QAAQ,IAAI,EAAE,eAAe,OAAO,QAAQ,IAAI,EAAE,aAAa,WAAW,KAAK,EAAE;AAAA,QAC1F;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,WAAW,GAAG;AACrB,aAAO,CAAC,SAAS,QAAQ;AAAA,IAC3B;AAEA,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,IAAI,KAAK,YAAY;AACzB,UAAM,OAAO,KAAK;AAClB,SAAK,MAAM;AACX,UAAM,SAAS,KAAK,kBAAkB;AACtC,UAAM,WAAW,KAAK,UAAU,KAAK,OAAO,UAAU;AAEtD,UAAM,aAAa,YAAY;AAC7B,UAAI,CAAC,YAAY;AACf,qBAAa,CAAC;AAAA,MAChB;AAEA,cAAI,qBAAAC,SAAc,UAAU,GAAG;AAC7B,cAAM,gBAAgB,uBAAO,OAAO,IAAI;AAExC,mBAAW,OAAO,OAAO,KAAK,UAAU,GAAG;AACzC,wBAAc,IAAI,GAAG,EAAE,IAAI,kBAAkB,WAAW,GAAG,CAAC;AAAA,QAC9D;AAEA,qBAAa;AAAA,MACf,OAAO;AACL,qBAAa,WAAW,IAAI,iBAAiB;AAAA,MAC/C;AAEA,UAAI;AACJ,UAAI;AACF,YAAI,WAAW,OAAO;AACpB,qBAAW,MAAM,KAAK,WAAW,MAAM,KAAK,UAAU;AAAA,QACxD,OAAO;AACL,qBAAW,MAAM,KAAK,WAAW,MAAM,KAAK,UAAU;AAAA,QACxD;AAAA,MACF,SAAS,OAAO;AACd,cAAM,MAAM,KAAK;AACjB,cAAM,KAAK,YAAY,KAAK;AAAA,MAC9B;AAEA,eAAS;AAET,aAAO,KAAK,qBAAqB,SAAS,WAAW,SAAS,OAAO;AAAA,IACvE;AAEA,WAAO,WAAW;AAAA,EACpB;AAAA,EAEA,WAAW,YAAY,OAAO,YAAY;AACxC,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,iBAAW,UAAU,MAAM;AACzB,mBAAW,IAAI,OAAO,YAAY,SAAU,KAAK,SAAS;AACxD,cAAI,KAAK;AACP,mBAAO,GAAG;AAEV;AAAA,UACF;AAIA,kBAAQ,EAAE,WAAW,MAAM,QAAQ,CAAC;AAAA,QACtC,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,WAAW,YAAY,OAAO,YAAY;AACxC,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,iBAAW,UAAU,MAAM;AACzB,mBAAW,IAAI,OAAO,YAAY,SAAU,KAAK,SAAS;AACxD,cAAI,KAAK;AACP,mBAAO,GAAG;AAEV;AAAA,UACF;AAIA,kBAAQ,EAAE,WAAW,MAAM,QAAQ,CAAC;AAAA,QACtC,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,YAAY,KAAK;AACf,YAAQ,IAAI,MAAM;AAAA,MAChB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,qBAAqB;AACxB,YAAI,IAAI,QAAQ,SAAS,+BAA+B,GAAG;AACzD,iBAAO,IAAI,sCAA0B;AAAA,YACnC,OAAO;AAAA,UACT,CAAC;AAAA,QACH;AAEA,YAAI,SAAS,CAAC;AAGd,YAAI,QAAQ,IAAI,QAAQ,MAAM,mBAAmB;AACjD,YAAI,UAAU,QAAQ,MAAM,UAAU,GAAG;AACvC,mBAAS,MAAM,CAAC,EAAE,MAAM,IAAI;AAAA,QAC9B,OAAO;AAEL,kBAAQ,IAAI,QAAQ,MAAM,gCAAgC;AAC1D,cAAI,UAAU,QAAQ,MAAM,UAAU,GAAG;AACvC,qBAAS,MAAM,CAAC,EAAE,MAAM,IAAI,EAAE,IAAI,qBAAmB,gBAAgB,MAAM,GAAG,EAAE,CAAC,CAAC;AAAA,UACpF;AAAA,QACF;AAEA,cAAM,SAAS,CAAC;AAChB,YAAI,UAAU;AAEd,mBAAW,SAAS,QAAQ;AAC1B,iBAAO;AAAA,YACL,IAAI;AAAA,cACF,KAAK,gCAAgC,KAAK;AAAA,cAC1C;AAAA;AAAA,cACA;AAAA,cACA,KAAK,YAAY,KAAK,SAAS,KAAK;AAAA,cACpC,KAAK;AAAA,cACL;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,YAAI,KAAK,OAAO;AACd,qBAAW,SAAS,KAAK,MAAM,WAAW,GAAG;AAC3C,gBAAI,MAAM,cAAU,eAAAC,SAAQ,MAAM,QAAQ,MAAM,KAAK,MAAM,KAAK;AAC9D,wBAAU,MAAM;AAChB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,eAAO,IAAI,kCAAsB,EAAE,SAAS,QAAQ,OAAO,KAAK,OAAO,CAAC;AAAA,MAC1E;AAAA,MAEA,KAAK;AACH,eAAO,IAAI,yBAAa,GAAG;AAAA,MAE7B;AACE,eAAO,IAAI,0BAAc,GAAG;AAAA,IAChC;AAAA,EACF;AAAA,EAEA,MAAM,uBAAuB,MAAM;AAEjC,WAAO,QAAQ;AAAA,MACb,KAAK,QAAQ,EAAE,IAAI,OAAM,SAAQ;AAC/B,aAAK,SAAS,CAAC;AACf,aAAK,UAAU;AACf,aAAK,SAAS,QAAQ,KAAK,MAAM;AACjC,aAAK,iBAAiB,KAAK;AAC3B,cAAM,UAAU,MAAM,KAAK,IAAI,uBAAuB,KAAK,IAAI,KAAK;AACpE,mBAAW,UAAU,SAAS;AAC5B,eAAK,OAAO,OAAO,KAAK,IAAI;AAAA,YAC1B,WAAW,OAAO;AAAA,YAClB,QAAQ;AAAA,YACR,OAAO;AAAA,UACT;AAAA,QACF;AAEA,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,oBAAoB;AAClB,QACE,KAAK,kBAAkB,KACvB,KAAK,cAAc,KACnB,KAAK,cAAc,KACnB,KAAK,cAAc,GACnB;AACA,aAAO,KAAK,QAAQ,YAAY,QAAQ;AAAA,IAC1C;AAEA,QACE,KAAK,cAAc,KACnB,KAAK,IAAI,YAAY,EAAE,SAAS,yBAAyB,YAAY,CAAC,GACtE;AACA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;",
  "names": ["merge", "isPlainObject", "isEqual"]
}
