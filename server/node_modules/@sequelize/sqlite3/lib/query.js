"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_exports = {};
__export(query_exports, {
  SqliteQuery: () => SqliteQuery
});
module.exports = __toCommonJS(query_exports);
var import_core = require("@sequelize/core");
var import_logger = require("@sequelize/core/_non-semver-use-at-your-own-risk_/utils/logger.js");
var import_isEqual = __toESM(require("lodash/isEqual"));
var import_isPlainObject = __toESM(require("lodash/isPlainObject"));
var import_merge = __toESM(require("lodash/merge"));
const debug = import_logger.logger.debugContext("sql:sqlite3");
function stringifyIfBigint(value) {
  if (typeof value === "bigint") {
    return value.toString();
  }
  return value;
}
class SqliteQuery extends import_core.AbstractQuery {
  getInsertIdField() {
    return "lastID";
  }
  _collectModels(include, prefix) {
    const ret = {};
    if (include) {
      for (const _include of include) {
        let key;
        if (!prefix) {
          key = _include.as;
        } else {
          key = `${prefix}.${_include.as}`;
        }
        ret[key] = _include.model;
        if (_include.include) {
          (0, import_merge.default)(ret, this._collectModels(_include.include, key));
        }
      }
    }
    return ret;
  }
  _handleQueryResponse(metaData, results) {
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {
      if (this.instance && this.instance.dataValues) {
        if (this.isInsertQuery() && !this.isUpsertQuery() && results.length === 0) {
          throw new import_core.EmptyResultError();
        }
        if (Array.isArray(results) && results[0]) {
          for (const attributeOrColumnName of Object.keys(results[0])) {
            const modelDefinition = this.model.modelDefinition;
            const attribute = modelDefinition.columns.get(attributeOrColumnName);
            const updatedValue = this._parseDatabaseValue(
              results[0][attributeOrColumnName],
              attribute?.type
            );
            this.instance.set(attribute?.attributeName ?? attributeOrColumnName, updatedValue, {
              raw: true,
              comesFromDatabase: true
            });
          }
        }
      }
      if (this.isUpsertQuery()) {
        return [this.instance, null];
      }
      return [
        this.instance || results && (this.options.plain && results[0] || results) || void 0,
        this.options.returning ? results.length : metaData.changes
      ];
    }
    if (this.isBulkUpdateQuery()) {
      return this.options.returning ? this.handleSelectQuery(results) : metaData.changes;
    }
    if (this.isDeleteQuery()) {
      return metaData.changes;
    }
    if (this.isShowConstraintsQuery()) {
      return results;
    }
    if (this.isSelectQuery()) {
      return this.handleSelectQuery(results);
    }
    if (this.isShowOrDescribeQuery()) {
      return results;
    }
    if (this.sql.includes("PRAGMA INDEX_LIST")) {
      return this.handleShowIndexesQuery(results);
    }
    if (this.sql.includes("PRAGMA INDEX_INFO")) {
      return results;
    }
    if (this.sql.includes("PRAGMA TABLE_INFO")) {
      const result = {};
      let defaultValue;
      for (const _result of results) {
        if (_result.dflt_value === null) {
          defaultValue = void 0;
        } else if (_result.dflt_value === "NULL") {
          defaultValue = null;
        } else {
          defaultValue = _result.dflt_value;
        }
        result[_result.name] = {
          type: _result.type,
          allowNull: _result.notnull === 0,
          defaultValue,
          primaryKey: _result.pk !== 0
        };
        if (result[_result.name].type === "TINYINT(1)") {
          result[_result.name].defaultValue = { 0: false, 1: true }[result[_result.name].defaultValue];
        }
        if (typeof result[_result.name].defaultValue === "string") {
          result[_result.name].defaultValue = result[_result.name].defaultValue.replaceAll("'", "");
        }
      }
      return result;
    }
    if (this.isRawQuery()) {
      return [results, metaData];
    }
    return this.instance;
  }
  async run(sql, parameters) {
    const conn = this.connection;
    this.sql = sql;
    const method = this.getDatabaseMethod();
    const complete = this._logQuery(sql, debug, parameters);
    const executeSql = async () => {
      if (!parameters) {
        parameters = [];
      }
      if ((0, import_isPlainObject.default)(parameters)) {
        const newParameters = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(parameters)) {
          newParameters[`$${key}`] = stringifyIfBigint(parameters[key]);
        }
        parameters = newParameters;
      } else {
        parameters = parameters.map(stringifyIfBigint);
      }
      let response;
      try {
        if (method === "run") {
          response = await this.#runSeries(conn, sql, parameters);
        } else {
          response = await this.#allSeries(conn, sql, parameters);
        }
      } catch (error) {
        error.sql = this.sql;
        throw this.formatError(error);
      }
      complete();
      return this._handleQueryResponse(response.statement, response.results);
    };
    return executeSql();
  }
  #allSeries(connection, query, parameters) {
    return new Promise((resolve, reject) => {
      connection.serialize(() => {
        connection.all(query, parameters, function(err, results) {
          if (err) {
            reject(err);
            return;
          }
          resolve({ statement: this, results });
        });
      });
    });
  }
  #runSeries(connection, query, parameters) {
    return new Promise((resolve, reject) => {
      connection.serialize(() => {
        connection.run(query, parameters, function(err, results) {
          if (err) {
            reject(err);
            return;
          }
          resolve({ statement: this, results });
        });
      });
    });
  }
  formatError(err) {
    switch (err.code) {
      case "SQLITE_CONSTRAINT_UNIQUE":
      case "SQLITE_CONSTRAINT_PRIMARYKEY":
      case "SQLITE_CONSTRAINT_TRIGGER":
      case "SQLITE_CONSTRAINT_FOREIGNKEY":
      case "SQLITE_CONSTRAINT": {
        if (err.message.includes("FOREIGN KEY constraint failed")) {
          return new import_core.ForeignKeyConstraintError({
            cause: err
          });
        }
        let fields = [];
        let match = err.message.match(/columns (.*?) are/);
        if (match !== null && match.length >= 2) {
          fields = match[1].split(", ");
        } else {
          match = err.message.match(/UNIQUE constraint failed: (.*)/);
          if (match !== null && match.length >= 2) {
            fields = match[1].split(", ").map((columnWithTable) => columnWithTable.split(".")[1]);
          }
        }
        const errors = [];
        let message = "Validation error";
        for (const field of fields) {
          errors.push(
            new import_core.ValidationErrorItem(
              this.getUniqueConstraintErrorMessage(field),
              "unique violation",
              // ValidationErrorItem.Origins.DB,
              field,
              this.instance && this.instance[field],
              this.instance,
              "not_unique"
            )
          );
        }
        if (this.model) {
          for (const index of this.model.getIndexes()) {
            if (index.unique && (0, import_isEqual.default)(index.fields, fields) && index.msg) {
              message = index.msg;
              break;
            }
          }
        }
        return new import_core.UniqueConstraintError({ message, errors, cause: err, fields });
      }
      case "SQLITE_BUSY":
        return new import_core.TimeoutError(err);
      default:
        return new import_core.DatabaseError(err);
    }
  }
  async handleShowIndexesQuery(data) {
    return Promise.all(
      data.reverse().map(async (item) => {
        item.fields = [];
        item.primary = false;
        item.unique = Boolean(item.unique);
        item.constraintName = item.name;
        const columns = await this.run(`PRAGMA INDEX_INFO(\`${item.name}\`)`);
        for (const column of columns) {
          item.fields[column.seqno] = {
            attribute: column.name,
            length: void 0,
            order: void 0
          };
        }
        return item;
      })
    );
  }
  getDatabaseMethod() {
    if (this.isBulkUpdateQuery() || this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {
      return this.options.returning ? "all" : "run";
    }
    if (this.isDeleteQuery() || this.sql.toLowerCase().includes("CREATE TEMPORARY TABLE".toLowerCase())) {
      return "run";
    }
    return "all";
  }
}
//# sourceMappingURL=query.js.map
