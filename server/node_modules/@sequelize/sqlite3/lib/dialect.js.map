{
  "version": 3,
  "sources": ["../src/dialect.ts"],
  "sourcesContent": ["import type { Sequelize } from '@sequelize/core';\nimport { AbstractDialect } from '@sequelize/core';\nimport { createNamedParamBindCollector } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/sql.js';\nimport { getSynchronizedTypeKeys } from '@sequelize/utils';\nimport * as DataTypes from './_internal/data-types-overrides.js';\nimport type { Sqlite3Module, SqliteConnectionOptions } from './connection-manager.js';\nimport { SqliteConnectionManager } from './connection-manager.js';\nimport { SqliteQueryGenerator } from './query-generator.js';\nimport { SqliteQueryInterface } from './query-interface.js';\nimport { SqliteQuery } from './query.js';\n\nexport interface SqliteDialectOptions {\n  /**\n   * If set to false, SQLite will not enforce foreign keys.\n   *\n   * @default true\n   */\n  foreignKeys?: boolean;\n\n  /**\n   * The sqlite3 library to use.\n   * If not provided, the sqlite3 npm library will be used.\n   * Must be compatible with the sqlite3 npm library API.\n   *\n   * Using this option should only be considered as a last resort,\n   * as the Sequelize team cannot guarantee its compatibility.\n   */\n  sqlite3Module?: Sqlite3Module;\n}\n\nconst DIALECT_OPTION_NAMES = getSynchronizedTypeKeys<SqliteDialectOptions>({\n  foreignKeys: undefined,\n  sqlite3Module: undefined,\n});\n\nconst CONNECTION_OPTION_NAMES = getSynchronizedTypeKeys<SqliteConnectionOptions>({\n  storage: undefined,\n  password: undefined,\n  mode: undefined,\n});\n\nexport class SqliteDialect extends AbstractDialect<SqliteDialectOptions, SqliteConnectionOptions> {\n  static supports = AbstractDialect.extendSupport({\n    DEFAULT: false,\n    'DEFAULT VALUES': true,\n    'UNION ALL': false,\n    'RIGHT JOIN': false,\n    returnValues: 'returning',\n    inserts: {\n      ignoreDuplicates: ' OR IGNORE',\n      updateOnDuplicate: ' ON CONFLICT DO UPDATE SET',\n      conflictFields: true,\n      onConflictWhere: true,\n    },\n    index: {\n      using: false,\n      where: true,\n      functionBased: true,\n    },\n    startTransaction: {\n      useBegin: true,\n      transactionType: true,\n    },\n    constraints: {\n      foreignKeyChecksDisableable: true,\n      add: false,\n      remove: false,\n    },\n    groupedLimit: false,\n    dataTypes: {\n      CHAR: false,\n      COLLATE_BINARY: true,\n      CITEXT: true,\n      DECIMAL: false,\n      // sqlite3 doesn't give us a way to do sql type-based parsing, *and* returns bigints as js numbers.\n      // issue: https://github.com/TryGhost/node-sqlite3/issues/922\n      BIGINT: false,\n      JSON: true,\n    },\n    // TODO: add support for JSON operations https://www.sqlite.org/json1.html (bundled in sqlite3)\n    //  be careful: json_extract, ->, and ->> don't have the exact same meanings as mysql & mariadb\n    jsonOperations: false,\n    jsonExtraction: {\n      unquoted: false,\n      quoted: false,\n    },\n    truncate: {\n      restartIdentity: false,\n    },\n    delete: {\n      limit: false,\n    },\n  });\n\n  readonly Query = SqliteQuery;\n  readonly connectionManager: SqliteConnectionManager;\n  readonly queryGenerator: SqliteQueryGenerator;\n  readonly queryInterface: SqliteQueryInterface;\n\n  constructor(sequelize: Sequelize, options: SqliteDialectOptions) {\n    super({\n      identifierDelimiter: '`',\n      options,\n      dataTypeOverrides: DataTypes,\n      sequelize,\n      minimumDatabaseVersion: '3.8.0',\n      dataTypesDocumentationUrl: 'https://www.sqlite.org/datatype3.html',\n      name: 'sqlite3',\n    });\n\n    this.connectionManager = new SqliteConnectionManager(this);\n    this.queryGenerator = new SqliteQueryGenerator(this);\n    this.queryInterface = new SqliteQueryInterface(this);\n  }\n\n  parseConnectionUrl(): SqliteConnectionOptions {\n    throw new Error(\n      'The \"url\" option is not supported in SQLite. Please use the \"storage\" option instead.',\n    );\n  }\n\n  createBindCollector() {\n    return createNamedParamBindCollector('$');\n  }\n\n  getDefaultSchema(): string {\n    // Our SQLite implementation doesn't support schemas\n    return '';\n  }\n\n  static getSupportedOptions() {\n    return DIALECT_OPTION_NAMES;\n  }\n\n  static getSupportedConnectionOptions(): readonly string[] {\n    return CONNECTION_OPTION_NAMES;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,kBAAgC;AAChC,iBAA8C;AAC9C,mBAAwC;AACxC,gBAA2B;AAE3B,gCAAwC;AACxC,6BAAqC;AACrC,6BAAqC;AACrC,mBAA4B;AAqB5B,MAAM,2BAAuB,sCAA8C;AAAA,EACzE,aAAa;AAAA,EACb,eAAe;AACjB,CAAC;AAED,MAAM,8BAA0B,sCAAiD;AAAA,EAC/E,SAAS;AAAA,EACT,UAAU;AAAA,EACV,MAAM;AACR,CAAC;AAEM,MAAM,sBAAsB,4BAA+D;AAAA,EAChG,OAAO,WAAW,4BAAgB,cAAc;AAAA,IAC9C,SAAS;AAAA,IACT,kBAAkB;AAAA,IAClB,aAAa;AAAA,IACb,cAAc;AAAA,IACd,cAAc;AAAA,IACd,SAAS;AAAA,MACP,kBAAkB;AAAA,MAClB,mBAAmB;AAAA,MACnB,gBAAgB;AAAA,MAChB,iBAAiB;AAAA,IACnB;AAAA,IACA,OAAO;AAAA,MACL,OAAO;AAAA,MACP,OAAO;AAAA,MACP,eAAe;AAAA,IACjB;AAAA,IACA,kBAAkB;AAAA,MAChB,UAAU;AAAA,MACV,iBAAiB;AAAA,IACnB;AAAA,IACA,aAAa;AAAA,MACX,6BAA6B;AAAA,MAC7B,KAAK;AAAA,MACL,QAAQ;AAAA,IACV;AAAA,IACA,cAAc;AAAA,IACd,WAAW;AAAA,MACT,MAAM;AAAA,MACN,gBAAgB;AAAA,MAChB,QAAQ;AAAA,MACR,SAAS;AAAA;AAAA;AAAA,MAGT,QAAQ;AAAA,MACR,MAAM;AAAA,IACR;AAAA;AAAA;AAAA,IAGA,gBAAgB;AAAA,IAChB,gBAAgB;AAAA,MACd,UAAU;AAAA,MACV,QAAQ;AAAA,IACV;AAAA,IACA,UAAU;AAAA,MACR,iBAAiB;AAAA,IACnB;AAAA,IACA,QAAQ;AAAA,MACN,OAAO;AAAA,IACT;AAAA,EACF,CAAC;AAAA,EAEQ,QAAQ;AAAA,EACR;AAAA,EACA;AAAA,EACA;AAAA,EAET,YAAY,WAAsB,SAA+B;AAC/D,UAAM;AAAA,MACJ,qBAAqB;AAAA,MACrB;AAAA,MACA,mBAAmB;AAAA,MACnB;AAAA,MACA,wBAAwB;AAAA,MACxB,2BAA2B;AAAA,MAC3B,MAAM;AAAA,IACR,CAAC;AAED,SAAK,oBAAoB,IAAI,kDAAwB,IAAI;AACzD,SAAK,iBAAiB,IAAI,4CAAqB,IAAI;AACnD,SAAK,iBAAiB,IAAI,4CAAqB,IAAI;AAAA,EACrD;AAAA,EAEA,qBAA8C;AAC5C,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EAEA,sBAAsB;AACpB,eAAO,0CAA8B,GAAG;AAAA,EAC1C;AAAA,EAEA,mBAA2B;AAEzB,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,sBAAsB;AAC3B,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,gCAAmD;AACxD,WAAO;AAAA,EACT;AACF;",
  "names": []
}
